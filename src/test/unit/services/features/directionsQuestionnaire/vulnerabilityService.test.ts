import * as draftStoreService from '../../../../../main/modules/draft-store/draftStoreService';
import {Claim} from '../../../../../main/common/models/claim';
import {
  getVulnerability,
  saveVulnerability,
} from '../../../../../main/services/features/directionsQuestionnaire/vulnerabilityService';
import {TestMessages} from '../../../../utils/errorMessageTestConstants';
import {Vulnerability} from '../../../../../main/common/models/directionsQuestionnaire/vulnerability';

jest.mock('../../../../../main/modules/draft-store');
jest.mock('../../../../../main/modules/draft-store/draftStoreService');
const mockGetCaseDataFromDraftStore = draftStoreService.getCaseDataFromStore as jest.Mock;
const mockSaveDraftClaim = draftStoreService.saveDraftClaim as jest.Mock;

describe('Vulnerability Service', () => {
  describe('get vulnerability', () => {
    it('should return undefined if vulnerability is not set', async () => {
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return new Claim();
      });
      const vulnerability = await getVulnerability('validClaimId');

      expect(vulnerability.vulnerabilityDetails).toBeUndefined();
      expect(vulnerability.isVulnerable).toBeUndefined();
    });

    it('should return vulnerability object with isVulnerable no', async () => {
      const claim = new Claim();
      claim.vulnerability = {
        isVulnerable: 'No',
      };
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return claim;
      });
      const vulnerability = await getVulnerability('validClaimId');

      expect(vulnerability.isVulnerable).toBe('No');
      expect(vulnerability.vulnerabilityDetails).toBeUndefined();
    });

    it('should return vulnerability object with isVulnerable yes and vulnerabilityDetails', async () => {
      const claim = new Claim();
      claim.vulnerability = {
        isVulnerable: 'Yes',
        vulnerabilityDetails: 'my details',
      };
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return claim;
      });
      const vulnerability = await getVulnerability('validClaimId');

      expect(vulnerability.isVulnerable).toBe('Yes');
      expect(vulnerability.vulnerabilityDetails).toBe('my details');
    });

    it('should return an error on redis failure', async () => {
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        throw new Error(TestMessages.REDIS_FAILURE);
      });

      await expect(getVulnerability('claimId')).rejects.toThrow(TestMessages.REDIS_FAILURE);
    });
  });

  describe('save vulnerability', () => {
    const vulnerability: Vulnerability = {
      isVulnerable: 'No',
    };

    it('should save vulnerability successfully', async () => {
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return new Claim();
      });
      const spySave = jest.spyOn(draftStoreService, 'saveDraftClaim');

      await saveVulnerability('validClaimId', vulnerability);

      expect(spySave).toHaveBeenCalledWith('validClaimId', {vulnerability});
    });

    it('should update claim vulnerability successfully', async () => {
      const claim = new Claim();
      claim.vulnerability = vulnerability;
      const updatedVulnerability: Vulnerability = {
        isVulnerable: 'Yes',
        vulnerabilityDetails: 'details',
      };
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return claim;
      });

      const spySave = jest.spyOn(draftStoreService, 'saveDraftClaim');

      await saveVulnerability('validClaimId', updatedVulnerability);

      expect(spySave).toHaveBeenCalledWith('validClaimId', {vulnerability: updatedVulnerability});
    });

    it('should return an error on redis failure', async () => {
      mockGetCaseDataFromDraftStore.mockImplementation(async () => {
        return new Claim();
      });
      mockSaveDraftClaim.mockImplementation(async () => {
        throw new Error(TestMessages.REDIS_FAILURE);
      });

      await expect(saveVulnerability('claimId', {isVulnerable: 'No'})).rejects.toThrow(TestMessages.REDIS_FAILURE);
    });
  });
});
